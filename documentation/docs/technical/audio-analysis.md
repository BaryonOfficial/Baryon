---
sidebar_position: 2
---

# Audio Analysis Pipeline

## Implementation Details

### Audio Processing Components

The audio pipeline processes three critical pieces of data:

1. **Frequency Bin Amplitudes** (`freqData: Uint8Array`)

   - Obtained via `THREE.AudioAnalyser.getFrequencyData()`
   - Returns `Uint8Array` containing amplitude values (0-255) for each frequency bin
   - Length is `fftSize/2` (2048 values for fftSize of 4096)
   - Each value represents the amplitude strength at that frequency (0 = silence, 255 = maximum)
   - Used to match amplitudes with detected pitches for Chladni pattern calculation

2. **Average Amplitude** (`avgAmplitude: number`)

   - Obtained via `THREE.AudioAnalyser.getAverageFrequency()`
   - Returns single `number` value between 0-255
   - 0 represents silence, 255 represents maximum average amplitude
   - Used for global visualization intensity

3. **Pitch Data** (`essentiaData: Float32Array`)
   - Generated by AudioWorklet's PredominantPitchMelodia algorithm
   - Stored in `Float32Array` within SharedArrayBuffer for real-time transfer
   - Length determined by `capacity` (default: 5)
   - Contains detected pitch frequencies in Hz
   - Combined with frequency bin amplitudes in shader calculations

### Data Flow Types

```typescript
// Audio analysis result type
interface AudioAnalysisResult {
  avgAmplitude: number; // 0-255 range
  freqData: Uint8Array; // Length of fftSize/2, values 0-255
}

// GPGPU computation data
interface GPGPUComputation {
  essentiaData: Float32Array; // Length of capacity, contains pitch frequencies
  // ... other GPGPU properties
}
```

### Data Flow

```typescript
// In AudioManager
processAudioData(gpgpu: GPGPUComputation) {
  // Read pitch data from AudioWorklet
  if (audioReader.available_read() >= 1) {
    audioReader.dequeue(gpgpu.essentiaData);
  }

  // Get amplitude data
  const { avgAmplitude, freqData } = this.audioAnalysis();

  // Update GPU textures with both pitch and amplitude data
  // This allows shaders to correlate pitches with their amplitudes
  updateGPGPUAmplitudes(gpgpu, avgAmplitude, freqData);
}
```

## Framework Migration Guide

### JUCE/VST3 Migration Requirements

To maintain compatibility, the JUCE implementation needs to provide three key data streams:

1. **Frequency Bin Amplitudes**

```cpp
class AudioProcessor : public juce::AudioProcessor {
    void processBlock(juce::AudioBuffer<float>& buffer) {
        // FFT analysis to get frequency bin amplitudes
        juce::dsp::FFT fft(fftOrder);

        // Must match current format:
        // - FFT size: 4096 samples
        // - Output: Uint8Array of amplitudes (0-255)
        // - Each bin represents amplitude at that frequency
        for (int i = 0; i < fftSize/2; ++i) {
            frequencyData[i] = juce::jmap(fftData[i], 0.0f, 1.0f, 0.0f, 255.0f);
        }
    }
};
```

2. **Average Amplitude**

```cpp
float getAverageAmplitude(const juce::AudioBuffer<float>& buffer) {
    // Calculate RMS or peak amplitude
    // Must match THREE.js range (0-255)
    float sum = 0.0f;
    // ... calculation ...
    return sum * 255.0f; // Scale to match current range
}
```

3. **Polyphonic Pitch Detection**

```cpp
class PitchProcessor {
    void processPitch(const juce::AudioBuffer<float>& buffer) {
        // Any polyphonic pitch detection algorithm that can:
        // - Detect multiple concurrent pitches (polyphonic detection)
        // - Output up to `capacity` simultaneous pitches per frame (currently fixed at 5)
        // - Work in real-time
        // Output format: Float32Array of frequencies in Hz

        // Future consideration: Flexible capacity implementation
    }
};
```

### Integration Requirements

1. **Data Synchronization**

   - All three data streams must be synchronized
   - Pitch data must correlate with frequency bin amplitudes
   - Real-time processing and transfer required

2. **Format Compatibility**

   - FFT size: 4096 samples
   - Amplitude range: 0-255 (Uint8Array)
   - Pitch data: Float32Array[capacity] of frequencies in Hz
   - Fixed capacity in initial implementation (default: 5)

3. **Performance Requirements**
   - Low-latency processing
   - Thread-safe data transfer
   - Efficient memory usage
